package com.safetynet.api.service.alertssafetynetservice;

import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import com.safetynet.api.model.FireStation;
import com.safetynet.api.model.Person;
import com.safetynet.api.service.dataservice.FireStationService;
import com.safetynet.api.service.dataservice.PersonService;

@SpringBootTest
class SearchingInfoOfResidentOfStationNumberImplTest {
	@Autowired
	SearchingInfoOfResidentOfStationNumberImpl infoOfResidentsByStationNumberUnderTest;

	@MockBean
	PersonService personService;
	
	@MockBean
	FireStationService fireStationService;
	
	@MockBean
	CalculatorAgeOfResidentImpl calculatorAge;
	
	private static Person personTest;
	private static List<Person> listOfPersonsTest;
	private static FireStation firestationTest;
	private static List<FireStation> listOfFireStationsTest;
	
	@BeforeAll
	static void setUp() {
		personTest = new Person("Millie", "Leperlier", "112 address", "city", "97451", "841-874-2512",
				"millie@email.com");
		personTest.setId("Millie Leperlier");
		listOfPersonsTest = new ArrayList<Person>();
		listOfPersonsTest.add(personTest);
		
		firestationTest= new FireStation("5", "112 address");
		firestationTest.setId("112-5-65");
		listOfFireStationsTest = new ArrayList<FireStation>();
		listOfFireStationsTest.add(firestationTest);
	}
	
	@Test
	void testSearchInfoOfResident() throws Exception {
		when(personService.getAllPersons()).thenReturn(listOfPersonsTest);
		when(fireStationService.getFireStationsByStationNumber( "5")).thenReturn(listOfFireStationsTest);
		when(calculatorAge.calculateAgeOfResident("Millie Leperlier")).thenReturn(BigInteger.valueOf(34));
		try {
			List<Map<String, String>>resultListOfResidentsOfStationNumber= infoOfResidentsByStationNumberUnderTest
					.searchInfoOfResident("5");
			
			verify(personService).getAllPersons();
			verify(fireStationService).getFireStationsByStationNumber(any(String.class));
			verify(calculatorAge).calculateAgeOfResident(any(String.class));
			assertFalse(resultListOfResidentsOfStationNumber.isEmpty());
			for (Map<String, String> resident :resultListOfResidentsOfStationNumber) {
				assertAll(
						"assertion all data of resident in of map generated by the method searchInfoOfResident with station number '5'",
						() -> assertEquals(personTest.getFirstName(), resident.get("firstName")),
						() -> assertEquals(personTest.getLastName(), resident.get("lastName")),
						() -> assertEquals(personTest.getAddress(), resident.get("address")),
						() -> assertEquals(personTest.getPhone(), resident.get("phone")),
						() -> assertEquals("34", resident.get("age")));
			}
		} catch (AssertionError e) {
			fail(e.getMessage());
		}
	}

	@Test
	@DisplayName("Given no existing resident found by no existing stationNumber 6 when generate a map with info of resident  the method should return error and null")
	void testSearchInfoOfResident_WithResidentNotFoundByStationNumber() throws Exception {
		when(fireStationService.getFireStationsByStationNumber( "6")).thenThrow(NullPointerException.class);
		
		try {
			List<Map<String, String>>resultListOfResidentsOfStationNumber= infoOfResidentsByStationNumberUnderTest
					.searchInfoOfResident("6");
			
			verify(personService).getAllPersons();
			verify(fireStationService).getFireStationsByStationNumber(any(String.class));
			verify(calculatorAge,Mockito.times(0)).calculateAgeOfResident(any(String.class));
			assertTrue(resultListOfResidentsOfStationNumber.isEmpty());
		}catch (NullPointerException e) {
					assertThrows(NullPointerException.class,
							() -> infoOfResidentsByStationNumberUnderTest
							.searchInfoOfResident("6"));
		} catch (AssertionError e) {
			fail(e.getMessage());
		}	
	}


	@Test
	@DisplayName("Given resident found by stationNumber with birthdate incorrect when generate a map with info of resident  the method should return 'error!' in key'age' instead age '0' ")
	void testSearchInfoOfResident_WithAgeOfResidentNotCalculated() throws Exception {
		when(personService.getAllPersons()).thenReturn(listOfPersonsTest);
		when(fireStationService.getFireStationsByStationNumber( "5")).thenReturn(listOfFireStationsTest);
		when(calculatorAge.calculateAgeOfResident("Millie Leperlier")).thenReturn(BigInteger.valueOf(0));
		try {
			List<Map<String, String>> listOfResidentsWithSameAddress =infoOfResidentsByStationNumberUnderTest
					.searchInfoOfResident("5");
			
			verify(personService).getAllPersons();
			verify(fireStationService).getFireStationsByStationNumber(any(String.class));
			verify(calculatorAge).calculateAgeOfResident(any(String.class));
			assertNotNull(listOfResidentsWithSameAddress);
			for (Map<String, String> resident : listOfResidentsWithSameAddress) {
				assertEquals(" error! ", resident.get("age"));
			}
		} catch (NullPointerException e) {
			assertThrows(NullPointerException.class,
					() -> infoOfResidentsByStationNumberUnderTest.searchInfoOfResident("5"));
		} catch (AssertionError e) {
			fail(e.getMessage());
		}
	}
}
